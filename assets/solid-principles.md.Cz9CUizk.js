import{_ as l,C as o,c as n,o as r,a2 as e,b as d,w as a,a as s,G as h,a3 as E}from"./chunks/framework.M5Qft685.js";const S=JSON.parse('{"title":"SOLID原則とは","description":"","frontmatter":{},"headers":[],"relativePath":"solid-principles.md","filePath":"solid-principles.md"}'),p={name:"solid-principles.md"};function c(A,t,u,b,f,g){const i=o("Mermaid");return r(),n("div",null,[t[1]||(t[1]=e('<h1 id="solid原則とは" tabindex="-1">SOLID原則とは <a class="header-anchor" href="#solid原則とは" aria-label="Permalink to &quot;SOLID原則とは&quot;">​</a></h1><p>SOLID原則は、保守性・拡張性・再利用性の高いソフトウェアを構築するための設計指針であり、特にオブジェクト指向プログラミングにおいて重要です。<br> これらの原則は、開発後の変更要求に柔軟に対応できる「良い設計」を支えるものです。<br> 2000年代にRobert C. Martin氏によって提唱されました。</p><table tabindex="0"><thead><tr><th>頭文字</th><th>原則</th><th>説明</th><th>得られるメリット</th></tr></thead><tbody><tr><td><strong>S</strong></td><td><a href="./single-responsibility-principle.html">単一責任の原則</a></td><td>クラスは「たった一人のアクター」に対して責任を持つべき</td><td>変更理由が明確になり、修正や拡張がしやすくなる</td></tr><tr><td><strong>O</strong></td><td><a href="./open-closed-principle.html">オープンクローズドの原則</a></td><td>拡張に開かれ、修正に閉じているべき</td><td>既存コードを壊さずに新しい振る舞いを追加できる</td></tr><tr><td><strong>L</strong></td><td><a href="./liskov-substitution-principle.html">リスコフの置換原則</a></td><td>サブタイプはスーパータイプと置換可能でなければならない</td><td>継承関係の一貫性を保ち、安全な拡張が可能になる</td></tr><tr><td><strong>I</strong></td><td><a href="./interface-segregation-principle.html">インターフェース分離の原則</a></td><td>クライアントにとって不要なメソッドへの依存を強制しない</td><td>小さなインターフェースを提供し、結合度を下げる</td></tr><tr><td><strong>D</strong></td><td><a href="./dependency-inversion-principle.html">依存性逆転の原則</a></td><td>上位モジュールと下位モジュールは抽象に依存すべき</td><td>実装に依存せず、モジュール間の独立性が高まる</td></tr></tbody></table><h2 id="なぜsolidが必要なのか" tabindex="-1">なぜSOLIDが必要なのか？ <a class="header-anchor" href="#なぜsolidが必要なのか" aria-label="Permalink to &quot;なぜSOLIDが必要なのか？&quot;">​</a></h2><p>現代のソフトウェア開発では、リリース後の機能追加・修正・保守が避けられません。<br> SOLID原則は、そのような変化に柔軟に対応できる設計を実現するために重要な指針です。</p><h2 id="solid原則を適用するメリット" tabindex="-1">SOLID原則を適用するメリット <a class="header-anchor" href="#solid原則を適用するメリット" aria-label="Permalink to &quot;SOLID原則を適用するメリット&quot;">​</a></h2><p>SOLID原則を適用することで、以下のような問題を解決できます。</p><h3 id="👎-非solidなコードの問題点" tabindex="-1">👎 非SOLIDなコードの問題点 <a class="header-anchor" href="#👎-非solidなコードの問題点" aria-label="Permalink to &quot;👎 非SOLIDなコードの問題点&quot;">​</a></h3><ul><li>ちょっとした修正が、意図しない別の場所に影響してバグが発生する</li><li>簡単な機能追加のはずなのに、多くの既存コードを変更する必要がある</li><li>コードの構造が複雑で、全体を理解するのに時間がかかる</li><li>再利用しづらく、似たような処理を何度も書いてしまう</li><li>モジュール同士の結びつきが強く、テストがしにくい</li></ul><h3 id="👍-solidなコードのメリット" tabindex="-1">👍 SOLIDなコードのメリット <a class="header-anchor" href="#👍-solidなコードのメリット" aria-label="Permalink to &quot;👍 SOLIDなコードのメリット&quot;">​</a></h3><ul><li>拡張性が高く、新機能の追加が容易</li><li>変更の影響範囲が局所的で、予測しやすい</li><li>モジュール単位でのテストが容易</li><li>コードの再利用性が高く、保守性が向上</li><li>チーム開発での理解・共有がしやすい</li></ul><h2 id="solid原則間の関連性" tabindex="-1">SOLID原則間の関連性 <a class="header-anchor" href="#solid原則間の関連性" aria-label="Permalink to &quot;SOLID原則間の関連性&quot;">​</a></h2><p>各原則は独立していますが、相互に関連し合っています。</p><ul><li><strong>単一責任の原則</strong>を守ることで、一つのクラスが複数の役割を持たなくなり、<strong>オープンクローズドの原則</strong>の適用が容易になります</li><li><strong>リスコフの置換原則</strong>は<strong>オープンクローズドの原則</strong>を支え、拡張性の高いコードを実現します</li><li><strong>インターフェース分離の原則</strong>と<strong>依存性逆転の原則</strong>は互いに補完し合い、疎結合なモジュール設計を促進します</li></ul><h3 id="solid原則の関連性" tabindex="-1">SOLID原則の関連性 <a class="header-anchor" href="#solid原則の関連性" aria-label="Permalink to &quot;SOLID原則の関連性&quot;">​</a></h3>',15)),(r(),d(E,null,{default:a(()=>[h(i,{id:"mermaid-194",class:"mermaid",graph:"graph%20TD%0A%20%20%20%20S%5B%E5%8D%98%E4%B8%80%E8%B2%AC%E4%BB%BB%E3%81%AE%E5%8E%9F%E5%89%87%5D%20--%3E%20O%5B%E3%82%AA%E3%83%BC%E3%83%97%E3%83%B3%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%BA%E3%83%89%E3%81%AE%E5%8E%9F%E5%89%87%5D%0A%20%20%20%20L%5B%E3%83%AA%E3%82%B9%E3%82%B3%E3%83%95%E3%81%AE%E7%BD%AE%E6%8F%9B%E5%8E%9F%E5%89%87%5D%20--%3E%20O%0A%20%20%20%20I%5B%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%95%E3%82%A7%E3%83%BC%E3%82%B9%E5%88%86%E9%9B%A2%E3%81%AE%E5%8E%9F%E5%89%87%5D%20--%3E%20D%5B%E4%BE%9D%E5%AD%98%E6%80%A7%E9%80%86%E8%BB%A2%E3%81%AE%E5%8E%9F%E5%89%87%5D%0A%20%20%20%20D%20--%3E%20O%0A%20%20%20%20%0A%20%20%20%20subgraph%20%22%E9%AB%98%E5%87%9D%E9%9B%86%22%0A%20%20%20%20%20%20%20%20S%0A%20%20%20%20end%0A%20%20%20%20%0A%20%20%20%20subgraph%20%22%E6%8B%A1%E5%BC%B5%E6%80%A7%22%0A%20%20%20%20%20%20%20%20O%0A%20%20%20%20%20%20%20%20L%0A%20%20%20%20end%0A%20%20%20%20%0A%20%20%20%20subgraph%20%22%E7%96%8E%E7%B5%90%E5%90%88%22%0A%20%20%20%20%20%20%20%20I%0A%20%20%20%20%20%20%20%20D%0A%20%20%20%20end%0A"})]),fallback:a(()=>t[0]||(t[0]=[s(" Loading... ")])),_:1})),t[2]||(t[2]=e('<h2 id="学習を深めるためのリソース" tabindex="-1">学習を深めるためのリソース <a class="header-anchor" href="#学習を深めるためのリソース" aria-label="Permalink to &quot;学習を深めるためのリソース&quot;">​</a></h2><ul><li><a href="https://www.amazon.co.jp/dp/0134494164" target="_blank" rel="noreferrer">Clean Architecture: A Craftsman&#39;s Guide to Software Structure and Design</a> - Robert C. Martin著</li><li><a href="https://www.amazon.co.jp/dp/0135974445" target="_blank" rel="noreferrer">Agile Software Development, Principles, Patterns, and Practices</a> - Robert C. Martin著</li><li><a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" target="_blank" rel="noreferrer">The Principles of OOD</a> - Robert C. Martin公式サイト</li><li><a href="https://qiita.com/KouMatsu/items/ca4e26336cc04fbc93d8" target="_blank" rel="noreferrer">TypeScriptで学ぶSOLID原則（Qiita）</a></li><li><a href="https://dev.to/harshaash/solid-principles-with-typescript-1kfc" target="_blank" rel="noreferrer">SOLID Principles with TypeScript（dev.to）</a></li><li><a href="https://refactoring.guru/design-patterns/solid" target="_blank" rel="noreferrer">Refactoring.Guru: SOLID</a></li></ul>',2))])}const B=l(p,[["render",c]]);export{S as __pageData,B as default};
