import{_ as a,c as r,o as e,a2 as d}from"./chunks/framework.M5Qft685.js";const u=JSON.parse('{"title":"OOPと関数型における設計原則のまとめ","description":"SRP〜DIPまでの各SOLID原則におけるOOPとFPの実装手法と考え方の違いを総括した比較ガイド。","frontmatter":{"description":"SRP〜DIPまでの各SOLID原則におけるOOPとFPの実装手法と考え方の違いを総括した比較ガイド。"},"headers":[],"relativePath":"object-oriented-vs-functional/summary.md","filePath":"object-oriented-vs-functional/summary.md"}'),o={name:"object-oriented-vs-functional/summary.md"};function i(n,t,l,s,P,h){return e(),r("div",null,t[0]||(t[0]=[d('<h1 id="oopと関数型における設計原則のまとめ" tabindex="-1">OOPと関数型における設計原則のまとめ <a class="header-anchor" href="#oopと関数型における設計原則のまとめ" aria-label="Permalink to &quot;OOPと関数型における設計原則のまとめ&quot;">​</a></h1><p>このセクションでは、OOP（オブジェクト指向）とFP（関数型プログラミング）における設計原則（SRP、OCP、LSP、ISP、DIP）の適用方法と考え方の違いを総括します。</p><h2 id="各原則の適用比較" tabindex="-1">各原則の適用比較 <a class="header-anchor" href="#各原則の適用比較" aria-label="Permalink to &quot;各原則の適用比較&quot;">​</a></h2><table tabindex="0"><thead><tr><th>原則</th><th>OOPにおける実践</th><th>FPにおける実践</th></tr></thead><tbody><tr><td>SRP（単一責任の原則）</td><td>クラス単位で責務を分離する</td><td>関数単位で責務を分離し、副作用を分離する</td></tr><tr><td>OCP（開放/閉鎖原則）</td><td>インターフェースと継承で拡張</td><td>関数マップやデータ駆動設計で拡張</td></tr><tr><td>LSP（リスコフの置換原則）</td><td>インターフェースの継承における意味的な互換性の保証</td><td>型ガードと構造的な安全性による置換保証</td></tr><tr><td>ISP（インターフェース分離の原則）</td><td>機能単位に分割されたインターフェースを実装</td><td>関数を機能単位で注入・構成する</td></tr><tr><td>DIP（依存性逆転の原則）</td><td>インターフェースに依存し、依存注入で差し替え可能に</td><td>高階関数や引数による依存関数の注入</td></tr></tbody></table><h2 id="共通点と違い" tabindex="-1">共通点と違い <a class="header-anchor" href="#共通点と違い" aria-label="Permalink to &quot;共通点と違い&quot;">​</a></h2><ul><li>両者とも「責務の分離」「拡張性の確保」「テスト容易性」など設計上のゴールは共通している。</li><li>OOPは<strong>構造（クラスやインターフェース）で抽象化</strong>し、FPは<strong>関数とデータで抽象化</strong>する。</li><li>FPでは、状態を持たない分、副作用を外部から注入する形で「責務」を柔軟に管理できる。</li></ul><h2 id="どちらを選ぶべきか" tabindex="-1">どちらを選ぶべきか？ <a class="header-anchor" href="#どちらを選ぶべきか" aria-label="Permalink to &quot;どちらを選ぶべきか？&quot;">​</a></h2><ul><li>小規模なロジックや副作用の少ない処理には<strong>関数型</strong>が適している。</li><li>複雑な状態管理やエンティティ設計には<strong>OOP</strong>の恩恵を受けやすい。</li><li>実際には両者を<strong>併用するミックススタイル</strong>が現代的であり、文脈に応じて使い分けるのが理想。</li></ul><h2 id="最後に" tabindex="-1">最後に <a class="header-anchor" href="#最後に" aria-label="Permalink to &quot;最後に&quot;">​</a></h2><p>OOPとFPは対立するものではなく、補完しあう設計スタイルです。<br> 設計原則を理解し、それぞれの文脈に応じた適用ができることが、柔軟で保守性の高いコードを生む第一歩となります。</p>',10)]))}const O=a(o,[["render",i]]);export{u as __pageData,O as default};
