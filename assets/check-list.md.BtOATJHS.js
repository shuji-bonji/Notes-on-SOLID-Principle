import{_ as l,c as e,o as i,a2 as t}from"./chunks/framework.M5Qft685.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"check-list.md","filePath":"check-list.md"}'),r={name:"check-list.md"};function o(s,a,h,c,n,d){return i(),e("div",null,a[0]||(a[0]=[t('<h3 id="各原則のチェックリスト-コードレビュー時の確認用" tabindex="-1">各原則のチェックリスト（コードレビュー時の確認用） <a class="header-anchor" href="#各原則のチェックリスト-コードレビュー時の確認用" aria-label="Permalink to &quot;各原則のチェックリスト（コードレビュー時の確認用）&quot;">​</a></h3><h3 id="単一責任の原則-srp" tabindex="-1">単一責任の原則（SRP） <a class="header-anchor" href="#単一責任の原則-srp" aria-label="Permalink to &quot;単一責任の原則（SRP）&quot;">​</a></h3><ul><li>[ ] このクラスは1つの理由でしか変更されないか？</li><li>[ ] 責務が複数混在していないか？</li></ul><h3 id="オープンクローズドの原則-ocp" tabindex="-1">オープンクローズドの原則（OCP） <a class="header-anchor" href="#オープンクローズドの原則-ocp" aria-label="Permalink to &quot;オープンクローズドの原則（OCP）&quot;">​</a></h3><ul><li>[ ] 新しい機能追加の際に既存クラスを修正していないか？</li><li>[ ] ポリモーフィズムや拡張ポイントを利用しているか？</li></ul><h3 id="リスコフの置換原則-lsp" tabindex="-1">リスコフの置換原則（LSP） <a class="header-anchor" href="#リスコフの置換原則-lsp" aria-label="Permalink to &quot;リスコフの置換原則（LSP）&quot;">​</a></h3><ul><li>[ ] 派生クラスは親クラスとして振る舞えるか？</li><li>[ ] クライアントコードに影響なく置き換えられるか？</li></ul><h3 id="インターフェース分離の原則-isp" tabindex="-1">インターフェース分離の原則（ISP） <a class="header-anchor" href="#インターフェース分離の原則-isp" aria-label="Permalink to &quot;インターフェース分離の原則（ISP）&quot;">​</a></h3><ul><li>[ ] インターフェースは肥大化していないか？</li><li>[ ] クライアントが不要なメソッドに依存していないか？</li></ul><h3 id="依存性逆転の原則-dip" tabindex="-1">依存性逆転の原則（DIP） <a class="header-anchor" href="#依存性逆転の原則-dip" aria-label="Permalink to &quot;依存性逆転の原則（DIP）&quot;">​</a></h3><ul><li>[ ] 実装ではなく抽象に依存しているか？</li><li>[ ] 上位モジュールが下位モジュールに依存していないか？</li></ul>',11)]))}const _=l(r,[["render",o]]);export{p as __pageData,_ as default};
