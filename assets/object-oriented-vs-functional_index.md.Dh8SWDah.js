import{_ as a,c as e,o as r,a2 as d}from"./chunks/framework.M5Qft685.js";const c=JSON.parse('{"title":"OOPと関数型の比較","description":"","frontmatter":{},"headers":[],"relativePath":"object-oriented-vs-functional/index.md","filePath":"object-oriented-vs-functional/index.md"}'),o={name:"object-oriented-vs-functional/index.md"};function l(i,t,n,h,s,P){return r(),e("div",null,t[0]||(t[0]=[d('<h1 id="oopと関数型の比較" tabindex="-1">OOPと関数型の比較 <a class="header-anchor" href="#oopと関数型の比較" aria-label="Permalink to &quot;OOPと関数型の比較&quot;">​</a></h1><p>このセクションでは、SOLID原則に代表されるオブジェクト指向設計と、関数型プログラミング（FP）の考え方を比較し、それぞれの設計手法がどのように責務の分離や拡張性、柔軟性に影響を与えるかを明らかにします。</p><h2 id="対比の目的" tabindex="-1">対比の目的 <a class="header-anchor" href="#対比の目的" aria-label="Permalink to &quot;対比の目的&quot;">​</a></h2><ul><li>OOPにおける原則（特にSOLID）の意図や効果を再確認する</li><li>関数型プログラミングでも設計原則を応用・変換できるかを探る</li><li>異なるパラダイムでの設計例を通じて読者の理解を深める</li></ul><h2 id="今後の内容予定" tabindex="-1">今後の内容予定 <a class="header-anchor" href="#今後の内容予定" aria-label="Permalink to &quot;今後の内容予定&quot;">​</a></h2><table tabindex="0"><thead><tr><th>原則名</th><th>比較ページ</th></tr></thead><tbody><tr><td>単一責任の原則（SRP）</td><td><a href="./srp-oop-vs-fp.html">SRPにおけるOOPとFPの比較</a></td></tr><tr><td>開放/閉鎖原則（OCP）</td><td><a href="./ocp-oop-vs-fp.html">OCPにおけるOOPとFPの比較</a></td></tr><tr><td>リスコフの置換原則（LSP）</td><td><a href="./lsp-oop-vs-fp.html">LSPにおけるOOPとFPの比較</a></td></tr><tr><td>インターフェース分離の原則（ISP）</td><td><a href="./isp-oop-vs-fp.html">ISPにおけるOOPとFPの比較</a></td></tr><tr><td>依存性逆転の原則（DIP）</td><td><a href="./dip-oop-vs-fp.html">DIPにおけるOOPとFPの比較</a></td></tr><tr><td>まとめ</td><td><a href="./summary.html">適用可能な原則と限界</a></td></tr></tbody></table><h2 id="想定読者" tabindex="-1">想定読者 <a class="header-anchor" href="#想定読者" aria-label="Permalink to &quot;想定読者&quot;">​</a></h2><ul><li>OOPとFPの両方に関心があるソフトウェア開発者</li><li>SOLID原則を関数型でどう適用できるか知りたい人</li><li>実装例を比較したい技術者や学生</li></ul><hr><p>この比較はどちらの立場を優劣とするものではなく、それぞれの長所と特徴を理解することを目的としています。</p>',10)]))}const f=a(o,[["render",l]]);export{c as __pageData,f as default};
